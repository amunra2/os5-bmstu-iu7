\setcounter{page}{2}

\chapter{Необходимые понятия}

В процессе изложения нужны следующие понятия.

\begin{enumerate}
    \item \textbf{Тик} - период времени между двумя последующими прерываниями таймера.
    \item \textbf{Основной тик} - период времени, равный $N$ тикам таймера, где число $N$ зависит от конкретного варианта системы. 
    \item \textbf{Квант времени} - временной интервал, в течение которого процесс может использовать процессор до вытеснения его другим процессом.
\end{enumerate}


\chapter{Функции обработчика прерывания от системного таймера в защищенном режиме}

Поскольку обработчик прерывания от системного таймера имеет наивысший приоритет, то никакая другая работа не может выполняться в системе во время его срабатывания.

\section{ОС Unix}
\subsection{По тику}
\begin{enumerate}
    \item Инкремент часов и других таймеров системы.
    \item Декремент кванта.
    \item Инкремент счетчика тиков аппаратного таймера.
    \item Инкремент поля \textit{p\_cpu} структуры  \textit{proc} до максимального значения в \textit{127}, то есть инкремент счетчика использования процессора текущим процессом.
    \item Декремент счетчика времени до отправления на выполнение отложенных вызовов. Когда счетчик становится равен нулю, то происходит выставление флага обработчика отложенного вызова.
\end{enumerate}


\subsection{По главному тику}
\begin{enumerate}
    \item Распознает отложенные вызовы функции, которые относятся к работе планировщика.
    \item В нужные моменты пробуждает системные процессы (например, swapper и pagedaemon). \textit{Пробуждать} - распознать отложенный вызов процедуры \textit{wakeup}, которая помещает дескрипторы процессов из списка \textit{спящие} в очередь -- \textit{готовы к выполнению}.
    \item Декремент счетчика времени, которое осталось до отправления одного из следующих сигналов:

    \begin{itemize}
        \item \textit{SIGPROF} - сигнал, который посылается процессу по истечении времени, заданного в таймере профилирования;
        \item \textit{SIGVTALRM} - сигнал, который посылается процессу по истечении времени, заданного в "виртуальном" таймере;
        \item \textit{SIGALRM} - сигнал, который посылается процессу по истечении времени, которое было предварительно задано функцией \textit{alarm()}
    \end{itemize}

\end{enumerate}


\subsection{По кванту}

Сигнал \textit{SIGXCPU} посылается текущему процессу, если он превысил выделенную для него квоту использования процессора (по умолчанию - обработчик сигнала прерывает выполнение процесса)



\section{ОС Windows}
\subsection{По тику}
\begin{enumerate}
    \item Инкремент счетчика системного времени.
    \item Декремент кванта.
    \item Декремент счетчиков времени отложенных задач.
    \item Когда активен механизм профилирования ядра, то инициализация отложенного вызова обработчика ловушки профилирования ядра происходит с помощью постановки объекта в очередь \textit{DPC} (обработчик ловушки профилирования регистрирует адрес команды, которая выполнялась на момент прерывания).
\end{enumerate}


\subsection{По главному тику}

Происходит освобождение объекта "событие", которое ожидает диспетчер настройки баланса.
Диспетчер настройки баланса (по событию от таймера) сканирует очередь готовых процессов и повышает приоритет процессов, которые находились в состоянии ожидания свыше \textit{4 секунд}.

\subsection{По кванту}

Происходит инициализация диспетчеризации потоков, добавление соответствующего объекта в очередь \textit{DPC}, где DPC (Deferred Procedure Call) - отложенный вызов процедуры.


\chapter{Пересчет динамических приоритетов}

\textit{Замечание:} динамически могут пересчитываться только \textit{приоритеты пользовательских процессов} (как в Unix, так и в Windows)

\section{ОС Unix}

Приоритет процесса задается любым целым числом в диапазоне от 0 до 127 (чем меньше число, тем выше приоритет), при этом:

\begin{itemize}
    \item 0 - 49 -- зарезервированы для ядра;
    \item 50 - 127 -- прикладные (приоритеты прикладных задач могут изменяться во времени)
\end{itemize}

В традиционных системах механизм планирования базируется на приоритетах. Приоритетом планирования (который изменяется с течением времени) обладает каждый процесс. Задача планировщика выбрать процесс, который обладает наивысшим проритетом. Если же некоторые процессы имеют равный приоритет, то применяется вытесняющее квантование времени. Изменение приоритетов процессов происходит динамически на основе количества процессорного времени, которое они используют. Если какой-либо из процессов, который имеет высокий приоритет, будет готов к выполнению, то планировщик вытеснит ради него текущий процесс даже в том случае, если тот не израсходовал свой квант времени.

В \textit{Unix} традиционное ядро является строго невытесняемым. Если процесс выполняется в режиме ядра (то есть в течение исполнения системного вызова или прерывания), то ядро не заставит такой процесс уступить процессор какому-либо высокоприоритетному процессу. Однако в современных системах Unix ядро является вытесняемым, поэтому процесс в режиме ядра может быть вытеснен процессом с более высоким приоритетом. Ядро было сделано вытесняемым, чтобы система могла обслуживать процессы реального времени (например, видео и аудио).

Приоритет прикладных задач зависит от:

\begin{itemize}
    \item \textit{фактора любезности (nice)} -- целое число в диапазоне от 0 до 39 (по умолчанию -- 20). Если значение увеличить, то приоритет уменьшится. При этом фоновые процессы автоматически имеют более высокие значения данного фактора (пользователь может поменять приоритет процесса, изменяя этот фактор, но только в сторону уменьшения приоритета, и только суперпользователь может повысить приоритет процесса);
    \item крайней измеренной величины использования процессора.
\end{itemize}

В структуре \textit{proc} содержутся следующие поля, которые относятся к приоритетам:

\img{35mm}{proc}{Поля структуры proc}

Значение в поле \textit{p\_pri} используется планировщиком для принятия решения о том, какой процесс нужно отправить на выполнение (\textit{p\_pri} и \textit{p\_usrpri} равны, если процесс находится в режиме задачи).

Значение \textit{p\_pri} может быть повышено планировщиком для того, чтобы выполнить процесс в режиме ядра. Тогда \textit{p\_usrpri} будет использоваться для хранения приоритета, который будет назначен процессу при возврате в режим задачи.

Поле \textit{p\_cpu} инициализируется нулем при создании процесса. Обработчик таймера на каждом тике увеличивает значение в этом поле текущего проесса на 1 до максимального значения в 127.

Ядро системы связывает приоритет сна с событием или ожидаемым ресурсом, из-за которого процесс может блокироваться. Приоритет сна лежит в диапазоне от 0 до 49, так как определяется для ядра.

Когда процесс ''просыпается'', ядро устанавливает в поле \textit{p\_pri} приоритет сна (значение приоритера из диапазона системных вызовов, которое зависит от события или ресурса, по которому проиозошла блокировка).

На рисунке \ref{img:sleep_prior} представлены значения приоритета сна в системе 4.3BSD.

\img{50mm}{sleep_prior}{Приоритет сна в ОС 4.3BSD}

Также на рисунке \ref{img:sleep_robachevsky} приведена таблица системных приоритетов сна из книги Андрея Робачевского:

\img{50mm}{sleep_robachevsky}{Приоритет сна из книги А. Робаческий "Операционная система UNIX"}

Ядро системы каждую секунду инициализирует отложенный вызов процедуры \textit{schedcpu()}, которая уменьшает значение \textit{p\_cpu} каждого процесса, исходя из фактора "полураспада", который в системе \textit{4.3BSD} считается так:

\begin{equation}
    decay = (2 * load\_average) / (2 * load\_average + 1)
\end{equation}

где \textit{load\_average} - среднее количество процессов, находящихся в состонии готовности к выполнению, за последнюю секунду.

Процедура \textit{schedcpu()} также пересчитывает приоритеты для режима задачи всех процессов по следующей формуле

\begin{equation}
    p\_usrpri = PUSER + (p\_cpu / 4) + (2 * p\_nice)
\end{equation}

где \textit{PUSER} - базовый приоритет в режиме задачи, равный 50.

Таким обрзаом, если процесс в последний раз (до вытеснения другим процессом) использовал большое количество процессорного времени, то его \textit{p\_cpu} будет увеличен. И это приведет к росту значения \textit{p\_userpri} и, следовательно, к понижению приоритета. Чем дольше процесс простаивает в очереди на выполнение, тем больше фактор полураспада уменьшает его \textit{p\_cpu}, что приодит к повышению его приоритета. Такая схема предотвращает бесконечное откладывание низкоприоритетных процессов в ОС (предпочтительна данная схема к процессам, которые осуществляют много операций ввода-вывода).

Таким образом, динамический пересчет приоритетов в режиме задачи  позволяет избежать бесконего откладывания. Сам пересчет может быть произведен по следующим причинам:

\begin{itemize}
    \item изменение фактора любезности процесса системным вызовом \textit{nice};
    \item ожидания процесса в очереди готовых к выполнению процессов;
    \item в зависимости от степени загруженнности процессора процессом \textit{p\_cpu};
    \item приоритет может быть повышен до соответствующего приоритета сна вследствие ожидания ресурса или события.
\end{itemize}



\section{ОС Windows}

Система планирования в \textit{Windows} является приоритетной и вытесняющей. При такой системе планирования всегда выполняется хотя бы один работоспособный (готовый) поток с самым высоким приоритетом (замечание - конкретные, имеющие высокий проритет и готовые к запуску потоки могут быть ограничены процессами, на которых им разрешено или предпочтительнее всего работать).

В \textit{Windows} планировка потоков происходит на основании приоритетов готовых к выполнению потоков -- поток с более низким приоритетом вытесняется планировщиком, когда поток с более высоки приоритетом становится готовым к выполнению.

В \textit{Windows} нет единого модуля или процедуры с названием "планировщик", потому что этот код рассредоточен по ядру (код, отвечающий за планирование, реализован в ядре). А совокупность процедур, которые выполняют эти обязанности, называются диспетчером ядра.

Диспетчеризация потоков может быть вызвана:

\begin{itemize}
    \item поток готов к выполнению (только что создан или вышел из состояния "ожидание")
    \item поток выходит из состояния "выполняется" (его квант истек, поток завершается или переходит в состояние "ожидание");
    \item изменилась привязка к процессорам (поток больше не может работать на процессоре, на котором он выполнялся);
    \item поменялся приоритет потока.
\end{itemize}

В Windows 32 уровня приоритетов: 0-15 -- 16 изменяющихся уровней (0 -- зарезервирован для потока обнуления страниц); 16-31 -- 16 уровней реального времени.


Исходя из двух разных позиций -- \textit{Windows API} и \textit{ядра Windows}, назначаются уровни приоритета.

Сначала \textit{Windows API} систематизирует процессы по классу приоритета, который им присваивается при создании:

\begin{itemize}
    \item реального времени (Real-time) - (4);
    \item высокий (High) - (3);
    \item выше обычного (Above Normal) - (6);
    \item обычный (Normal) - 2;
    \item ниже обычного (Below Normal) - (5);
    \item простоя (Idle) - (1);
\end{itemize}


Затем назначается относительный приоритет отдельных потоков внутри этих процессов:

\begin{itemize}
    \item критичный по времени (Time-critical) - 15;
    \item наивысший (Highest) - (2);
    \item выше обычного (Above Normal) - (1);
    \item обычный (Normal) - (0);
    \item ниже обычного (Below Normal) - (-1);
    \item самый низкий (Lowest) - (-2);
    \item простоя (Idle) - (-15);
\end{itemize}


Процесс по умолчанию наследует свой базовый приоритет у того процесса, который его создал.

На рисунке \ref{img:comp_prior} можно увидеть соответствие между приоритетами Windows API и ядра системы.


\img{50mm}{comp_prior}{Cоответствие между приоритетами Windows API и ядра системы}


Планировщик может повысить текущий приоритет потока (в динамическом диапазоне от 1 до 15) из-за следующих причин.

\begin{itemize}
    \item Повышение приоритета вследствие событий планировщика или диспетчера (сокращение задержек).

    % Когда наступают события диспетчера, вызываются процедуры, которые проверяют не должны ли на локальном процессоре быть намечены какие-либо потоки, которые не должны быть спланированы. При этом при каждом наступлении такого события вызывающий код может указать, кого типа повышение должно быть применено в потоку, а также, с каким приращением приоритета должно быть связано это повышение. 

    \item Повышение приоритета, связанное с завершением ожидания.

    % По умолчанию, поток, который выходит из состояния ожидания, должен как можно скорее приступить к выполнению.

    \item Повышение приоритета владельца блокировки.

    % Блокировка ресурсов исполняющей системы и блокировка критических разделов используют основные объекты диспетчеризации, поэтому в результате освобождения этих блокировок осуществляется повышение приоритетов, которые связаны с завершением ожидания.

    \item Повышение приоритета вследствие заврешения ввода-вывода.

    % При заврешении операций ввода-вывода, Windows дает временное повышение приоритета. При этом потоки, которые ожидали ввода-вывода имеют больше возможности запуститься (\ref{img:rec_prior}).

    \item Повышение приоритета при ождиании ресурсов исполняющей системы.

    % Когда поток пытается получить ресурс исполняющей системы, который уже занят другим потоком (находится в его владении), то он должен войти в состояние ожидания, пока поток не освободит ресурс. Для ограничения риска взаимных исключений, бесконечного ожидания не происходит - дается интервал времени в 500 мс. Если время вышло, а ресурсы не были получены, исполняющая система пытается предотвратить зависание ЦП путем блокировки диспетчера, повышение до 15 (если исходный приоритет владельца был меньше, чем у ожидающего и не равен 15) потока, который владеет ресурсом, или перезапуска их квантов и выполнения еще одного ожидания.

    \item Повышение приоритета потоков первого плана после ожидания.

    % При этом ожидается улчучшение скорости отклика интерактивных приложений (если дать приложениям первого плана небольшое повышение приоритета, то у них есть шанс после ожидания сразу приступить к работе).

    \item Повышение приоритета после пробуждения GUI потока.

    % Потоки, которые работают с окнами, получают дополнительное повышение приоритета на 2 из-за активности при работе с окнами (например, поступило сообщение).

    \item Повышение приоритета, связанные с перезагруженностью ЦП.

    % ДНБ (Диспетчер Настройки Баланса) сканирует очередь готовых потоков раз в секунду и, если обнаружены потоки, которые ожидают выполнения более 4 секунд, то ДНБ повышает их приоритет до 15 (когда квант истекает -- приоритет понижается до базового). Если поток не завершен или вытеснен потоком с более высоким приоритетом, то он возвращается в очередь готовых на выполнение потоков (сканируется лишь 16 готовых потоков и повышается приоритет максимум у 10 из них, при этом сканирование продолжается с того момента, где было прервано крайний раз).

    \item Повышение приоритетов для мультимедийных приложений и игр.

    % Такие потоки должны выполняться минимальными задержками. Драйвер MMCSS (MultiMedia Class Scheduler Service) повышает приоритеты таких процессов. Работает этот драйвер с: аудио, аудио профессионального качества, играми, захватом, воспроизведени, задачами администратора многооконного режима и распределением.
\end{itemize}


На рисунке \ref{img:rec_prior} предсталвены рекомендуемые значения повышения приоритета.

\img{35mm}{rec_prior}{Рекомендуемые значения повышения приоритета}


Также стоит упомянуть, что важным свойством планирования потоков является категория планирования. Это -- первичный фактор, который определяет приоритет потоков, зарегестрированных с MMCSS. Функции MMCSS временно повышают приоритет потоков, зарегестрированных с MMCSS до уровня, который соответствует категории планирования. Затем их приоритет снижения до уровня Exhausted, чтобы другие потоки тоже могли получить ресурс.

На рисунке \ref{img:kat_plan} представлены категории планирования.

\img{50mm}{kat_plan}{Категории планирования}



\chapter*{Вывод}

ОС Unix и ОС Windows -- системы разделения времени с вытеснением и динамическими приоритетами.

У обеих операционных систем функции обработчика прерывания от системного таймера схожи, так как они являются системами разделения времени.

Основные общие функции обработчика прерывания от системного таймера:

\begin{itemize}
    \item декремент кванта;
    \item декремент счетчиков времени (таймеров, часов, счетчиков времени отложенных действий, будильников реального времени);
    \item инициализация отложенных действий, которые относятся к работе планировщика.
\end{itemize}


В Unix приоритет пользовательского процесса (процесса в режиме задач) может динамически пересчитываться в зависимости от фактора любезности, результата последнего измерения использования процессора и базового приоритета.

В Windows когда создается процесс, ему назначается базовый приоритет, и относительно базового приоритета потоку назначается отнносительный приоритет, то есть у потока нет своего приоритета (приоритет потока пользовательского процесса может быть динамически пересчитан).

